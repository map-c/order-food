# 📊 报表模块实现文档

## 1. 模块概述

### 1.1 功能简介

报表模块是餐馆点餐系统的核心数据分析功能，为店主和管理人员提供全面的经营数据洞察。主要功能包括：

- **综合统计** - 营业额、订单数、客单价、利润率等核心指标
- **趋势分析** - 营业额与订单数趋势图表
- **分类分析** - 各类菜品销售额占比
- **热销分析** - 热销菜品 TOP 排行榜
- **时段分析** - 不同时段的营业数据对比
- **数据导出** - 支持 Excel 和 PDF 格式导出

### 1.2 技术架构

```
┌─────────────────────────────────────────────────────────┐
│                     报表页面 (/reports)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ ReportFilters│  │  ReportStats │  │ RevenueChart │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │CategoryChart │  │  TopDishes   │  │HourlyAnalysis│   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└─────────────────────────────────────────────────────────┘
                            ↓
                    ┌───────────────┐
                    │  SWR 数据获取  │
                    └───────────────┘
                            ↓
┌─────────────────────────────────────────────────────────┐
│                    后端 API 路由                          │
│  /api/reports/overview   - 综合报表数据                   │
│  /api/reports/revenue    - 营业额报表                     │
│  /api/reports/dishes     - 菜品销售报表                   │
│  /api/reports/hourly     - 时段分析报表                   │
│  /api/reports/export     - 数据导出                       │
└─────────────────────────────────────────────────────────┘
                            ↓
                    ┌───────────────┐
                    │  Prisma ORM   │
                    └───────────────┘
                            ↓
                    ┌───────────────┐
                    │  SQLite DB    │
                    └───────────────┘
```

### 1.3 核心指标说明

| 指标名称 | 计算公式 | 说明 |
|---------|---------|------|
| **总营业额** | `SUM(totalPrice) WHERE isPaid = true` | 已支付订单的总金额 |
| **订单总数** | `COUNT(*) WHERE status = 'completed'` | 已完成的订单数量 |
| **客单价** | `总营业额 / 订单总数` | 平均每单消费金额 |
| **利润率** | `(营业额 - 成本) / 营业额 × 100%` | 毛利润占比（需成本数据） |
| **增长率** | `(当前值 - 对比值) / 对比值 × 100%` | 与上期对比的增长百分比 |

---

## 2. 数据模型设计

### 2.1 报表数据结构

```typescript
// types/reports.ts

/**
 * 报表筛选参数
 */
export interface ReportFilters {
  startDate: string        // 开始日期 ISO 8601 格式
  endDate: string          // 结束日期
  compareStartDate?: string // 对比期开始日期（用于计算增长率）
  compareEndDate?: string   // 对比期结束日期
  reportType?: 'all' | 'revenue' | 'dishes' | 'hourly'
}

/**
 * 核心统计数据
 */
export interface ReportStats {
  totalRevenue: number      // 总营业额
  totalOrders: number       // 订单总数
  avgOrderValue: number     // 客单价
  profitRate: number        // 利润率（百分比）
  comparison?: {
    revenueGrowth: number   // 营业额增长率
    ordersGrowth: number    // 订单增长率
    avgOrderGrowth: number  // 客单价增长率
  }
}

/**
 * 营业额趋势数据点
 */
export interface RevenueDataPoint {
  date: string              // 日期
  revenue: number           // 营业额
  orders: number            // 订单数
  avgOrder: number          // 客单价
}

/**
 * 分类销售数据
 */
export interface CategorySales {
  categoryId: string
  categoryName: string
  totalRevenue: number
  totalOrders: number
  percentage: number        // 占总营业额的百分比
}

/**
 * 热销菜品数据
 */
export interface TopDishData {
  dishId: string
  dishName: string
  categoryName: string
  sales: number             // 销量
  revenue: number           // 营业额
  growth: number            // 增长率
}

/**
 * 时段分析数据
 */
export interface HourlyData {
  timeRange: string         // 时间段，如 "11:00-12:00"
  orders: number            // 订单数
  revenue: number           // 营业额
  avgOrder: number          // 客单价
}

/**
 * 综合报表响应
 */
export interface ReportOverview {
  stats: ReportStats
  revenueChart: RevenueDataPoint[]
  categoryChart: CategorySales[]
  topDishes: TopDishData[]
  hourlyAnalysis: HourlyData[]
}
```

### 2.2 统计维度定义

#### 时间维度
- **今天** - 当天 00:00 至当前时间
- **昨天** - 昨天 00:00 至 23:59
- **本周** - 本周一 00:00 至当前时间
- **本月** - 本月 1 日 00:00 至当前时间
- **本季度** - 本季度第一天 00:00 至当前时间
- **本年** - 1 月 1 日 00:00 至当前时间
- **自定义** - 用户指定的日期范围

#### 对比维度
- **环比** - 与上一个相同时间段对比（如本周 vs 上周）
- **同比** - 与去年同期对比（如本月 vs 去年本月）

### 2.3 时间维度处理

使用 `date-fns` 库进行日期处理：

```typescript
import {
  startOfDay,
  endOfDay,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  subDays,
  subWeeks,
  subMonths,
  format
} from 'date-fns'

export function getDateRange(range: string): { start: Date; end: Date } {
  const now = new Date()

  switch (range) {
    case 'today':
      return { start: startOfDay(now), end: now }

    case 'yesterday':
      const yesterday = subDays(now, 1)
      return { start: startOfDay(yesterday), end: endOfDay(yesterday) }

    case 'week':
      return { start: startOfWeek(now, { weekStartsOn: 1 }), end: now }

    case 'month':
      return { start: startOfMonth(now), end: now }

    default:
      return { start: startOfDay(now), end: now }
  }
}

export function getComparisonRange(range: string): { start: Date; end: Date } {
  const { start, end } = getDateRange(range)
  const duration = end.getTime() - start.getTime()

  const compareEnd = new Date(start.getTime() - 1)
  const compareStart = new Date(compareEnd.getTime() - duration)

  return { start: compareStart, end: compareEnd }
}
```

---

## 3. 后端 API 设计

### 3.1 API 端点列表

| 端点 | 方法 | 说明 | 查询参数 |
|------|------|------|---------|
| `/api/reports/overview` | GET | 获取综合报表数据 | `startDate`, `endDate`, `compareStartDate`, `compareEndDate` |
| `/api/reports/revenue` | GET | 获取营业额报表 | 同上 + `granularity` (hour/day/month) |
| `/api/reports/dishes` | GET | 获取菜品销售报表 | 同上 + `limit`, `categoryId` |
| `/api/reports/hourly` | GET | 获取时段分析报表 | `startDate`, `endDate` |
| `/api/reports/export` | POST | 导出报表数据 | `format` (excel/pdf), `reportType` |

### 3.2 统一响应格式

```typescript
// 成功响应
{
  success: true,
  data: T,
  message?: string
}

// 错误响应
{
  success: false,
  error: {
    code: string,
    message: string
  }
}
```

### 3.3 API 实现示例

#### 3.3.1 综合报表 API

```typescript
// app/api/reports/overview/route.ts
import { NextRequest } from 'next/server'
import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { apiResponse } from '@/lib/api-response'
import type { ReportOverview } from '@/types/reports'

const querySchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  compareStartDate: z.string().datetime().optional(),
  compareEndDate: z.string().datetime().optional(),
})

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)

    const params = {
      startDate: searchParams.get('startDate'),
      endDate: searchParams.get('endDate'),
      compareStartDate: searchParams.get('compareStartDate'),
      compareEndDate: searchParams.get('compareEndDate'),
    }

    // 验证参数
    const validationResult = querySchema.safeParse(params)
    if (!validationResult.success) {
      return apiResponse.error(
        '参数验证失败',
        'VALIDATION_ERROR',
        400
      )
    }

    const { startDate, endDate, compareStartDate, compareEndDate } = validationResult.data

    // 1. 获取核心统计数据
    const stats = await getReportStats(
      new Date(startDate),
      new Date(endDate),
      compareStartDate ? new Date(compareStartDate) : undefined,
      compareEndDate ? new Date(compareEndDate) : undefined
    )

    // 2. 获取营业额趋势数据
    const revenueChart = await getRevenueChart(
      new Date(startDate),
      new Date(endDate)
    )

    // 3. 获取分类销售数据
    const categoryChart = await getCategoryChart(
      new Date(startDate),
      new Date(endDate)
    )

    // 4. 获取热销菜品数据
    const topDishes = await getTopDishes(
      new Date(startDate),
      new Date(endDate),
      5 // TOP 5
    )

    // 5. 获取时段分析数据
    const hourlyAnalysis = await getHourlyAnalysis(
      new Date(startDate),
      new Date(endDate)
    )

    const data: ReportOverview = {
      stats,
      revenueChart,
      categoryChart,
      topDishes,
      hourlyAnalysis,
    }

    return apiResponse.success(data)
  } catch (error) {
    console.error('Get report overview error:', error)
    return apiResponse.error(
      '获取报表数据失败',
      'INTERNAL_ERROR',
      500
    )
  }
}

/**
 * 获取核心统计数据
 */
async function getReportStats(
  startDate: Date,
  endDate: Date,
  compareStartDate?: Date,
  compareEndDate?: Date
) {
  // 当前期间的统计
  const currentStats = await prisma.order.aggregate({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    _sum: {
      totalPrice: true,
    },
    _count: true,
  })

  const totalRevenue = currentStats._sum.totalPrice || 0
  const totalOrders = currentStats._count
  const avgOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0

  // 如果有对比期，计算增长率
  let comparison
  if (compareStartDate && compareEndDate) {
    const compareStats = await prisma.order.aggregate({
      where: {
        createdAt: {
          gte: compareStartDate,
          lte: compareEndDate,
        },
        isPaid: true,
      },
      _sum: {
        totalPrice: true,
      },
      _count: true,
    })

    const compareRevenue = compareStats._sum.totalPrice || 0
    const compareOrders = compareStats._count
    const compareAvgOrder = compareOrders > 0 ? compareRevenue / compareOrders : 0

    comparison = {
      revenueGrowth: compareRevenue > 0
        ? ((totalRevenue - compareRevenue) / compareRevenue) * 100
        : 0,
      ordersGrowth: compareOrders > 0
        ? ((totalOrders - compareOrders) / compareOrders) * 100
        : 0,
      avgOrderGrowth: compareAvgOrder > 0
        ? ((avgOrderValue - compareAvgOrder) / compareAvgOrder) * 100
        : 0,
    }
  }

  return {
    totalRevenue,
    totalOrders,
    avgOrderValue,
    profitRate: 58.3, // TODO: 需要成本数据计算真实利润率
    comparison,
  }
}

/**
 * 获取营业额趋势数据（按天聚合）
 */
async function getRevenueChart(startDate: Date, endDate: Date) {
  const orders = await prisma.order.groupBy({
    by: ['createdAt'],
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    _sum: {
      totalPrice: true,
    },
    _count: true,
  })

  // 按日期聚合
  const dailyData = new Map<string, { revenue: number; orders: number }>()

  orders.forEach((order) => {
    const date = order.createdAt.toISOString().split('T')[0]
    const existing = dailyData.get(date) || { revenue: 0, orders: 0 }

    dailyData.set(date, {
      revenue: existing.revenue + (order._sum.totalPrice || 0),
      orders: existing.orders + order._count,
    })
  })

  return Array.from(dailyData.entries()).map(([date, data]) => ({
    date,
    revenue: data.revenue,
    orders: data.orders,
    avgOrder: data.orders > 0 ? data.revenue / data.orders : 0,
  }))
}

/**
 * 获取分类销售数据
 */
async function getCategoryChart(startDate: Date, endDate: Date) {
  const categoryStats = await prisma.orderItem.groupBy({
    by: ['dishId'],
    where: {
      order: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        isPaid: true,
      },
    },
    _sum: {
      subtotal: true,
      quantity: true,
    },
  })

  // 获取菜品和分类信息
  const dishIds = categoryStats.map(stat => stat.dishId)
  const dishes = await prisma.dish.findMany({
    where: { id: { in: dishIds } },
    include: { category: true },
  })

  // 按分类聚合
  const categoryMap = new Map<string, { name: string; revenue: number; orders: number }>()

  categoryStats.forEach((stat) => {
    const dish = dishes.find(d => d.id === stat.dishId)
    if (!dish) return

    const existing = categoryMap.get(dish.categoryId) || {
      name: dish.category.name,
      revenue: 0,
      orders: 0,
    }

    categoryMap.set(dish.categoryId, {
      name: existing.name,
      revenue: existing.revenue + (stat._sum.subtotal || 0),
      orders: existing.orders + (stat._sum.quantity || 0),
    })
  })

  const totalRevenue = Array.from(categoryMap.values())
    .reduce((sum, item) => sum + item.revenue, 0)

  return Array.from(categoryMap.entries()).map(([categoryId, data]) => ({
    categoryId,
    categoryName: data.name,
    totalRevenue: data.revenue,
    totalOrders: data.orders,
    percentage: totalRevenue > 0 ? (data.revenue / totalRevenue) * 100 : 0,
  }))
}

/**
 * 获取热销菜品数据
 */
async function getTopDishes(startDate: Date, endDate: Date, limit: number) {
  const dishStats = await prisma.orderItem.groupBy({
    by: ['dishId'],
    where: {
      order: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        isPaid: true,
      },
    },
    _sum: {
      quantity: true,
      subtotal: true,
    },
    orderBy: {
      _sum: {
        quantity: 'desc',
      },
    },
    take: limit,
  })

  // 获取菜品详情
  const dishIds = dishStats.map(stat => stat.dishId)
  const dishes = await prisma.dish.findMany({
    where: { id: { in: dishIds } },
    include: { category: true },
  })

  // TODO: 计算增长率需要对比期数据

  return dishStats.map((stat, index) => {
    const dish = dishes.find(d => d.id === stat.dishId)
    return {
      dishId: stat.dishId,
      dishName: dish?.name || 'Unknown',
      categoryName: dish?.category.name || 'Unknown',
      sales: stat._sum.quantity || 0,
      revenue: stat._sum.subtotal || 0,
      growth: 0, // TODO: 实现增长率计算
    }
  })
}

/**
 * 获取时段分析数据
 */
async function getHourlyAnalysis(startDate: Date, endDate: Date) {
  const orders = await prisma.order.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    select: {
      createdAt: true,
      totalPrice: true,
    },
  })

  // 按小时聚合
  const hourlyMap = new Map<number, { orders: number; revenue: number }>()

  orders.forEach((order) => {
    const hour = order.createdAt.getHours()
    const existing = hourlyMap.get(hour) || { orders: 0, revenue: 0 }

    hourlyMap.set(hour, {
      orders: existing.orders + 1,
      revenue: existing.revenue + order.totalPrice,
    })
  })

  // 转换为时间段格式
  return Array.from(hourlyMap.entries())
    .map(([hour, data]) => ({
      timeRange: `${hour.toString().padStart(2, '0')}:00-${(hour + 1).toString().padStart(2, '0')}:00`,
      orders: data.orders,
      revenue: data.revenue,
      avgOrder: data.orders > 0 ? data.revenue / data.orders : 0,
    }))
    .sort((a, b) => parseInt(a.timeRange) - parseInt(b.timeRange))
}
```

---

## 4. 前端组件说明

### 4.1 组件树结构

```
ReportsPage (页面)
├── ReportFilters (筛选器)
│   ├── DateRangePicker (日期范围选择器)
│   ├── ReportTypeSelector (报表类型选择器)
│   └── ExportButtons (导出按钮)
├── ReportStats (统计卡片)
│   └── StatCard × 4 (单个统计卡片)
├── RevenueChart (营业额趋势图)
│   └── Recharts BarChart
├── CategoryChart (分类占比图)
│   └── Recharts PieChart
├── TopDishes (热销菜品表格)
│   └── Table (shadcn/ui)
└── HourlyAnalysis (时段分析表格)
    └── Table (shadcn/ui)
```

### 4.2 数据流向

```
用户交互（选择日期范围）
    ↓
ReportFilters 更新状态
    ↓
触发 SWR 重新请求
    ↓
调用 /api/reports/overview
    ↓
Prisma 查询数据库
    ↓
数据聚合计算
    ↓
返回 JSON 响应
    ↓
SWR 缓存数据
    ↓
各组件重新渲染
```

### 4.3 状态管理方案

使用 React Context + SWR 进行状态管理：

```typescript
// contexts/report-context.tsx
'use client'

import { createContext, useContext, useState, ReactNode } from 'react'
import useSWR from 'swr'
import { fetcher } from '@/lib/api-client'
import type { ReportFilters, ReportOverview } from '@/types/reports'

interface ReportContextType {
  filters: ReportFilters
  setFilters: (filters: ReportFilters) => void
  data?: ReportOverview
  isLoading: boolean
  error: any
}

const ReportContext = createContext<ReportContextType | undefined>(undefined)

export function ReportProvider({ children }: { children: ReactNode }) {
  const [filters, setFilters] = useState<ReportFilters>({
    startDate: new Date().toISOString(),
    endDate: new Date().toISOString(),
    reportType: 'all',
  })

  // 构建查询参数
  const queryParams = new URLSearchParams({
    startDate: filters.startDate,
    endDate: filters.endDate,
    ...(filters.compareStartDate && { compareStartDate: filters.compareStartDate }),
    ...(filters.compareEndDate && { compareEndDate: filters.compareEndDate }),
  })

  const { data, error, isLoading } = useSWR<ReportOverview>(
    `/api/reports/overview?${queryParams}`,
    fetcher
  )

  return (
    <ReportContext.Provider value={{ filters, setFilters, data, isLoading, error }}>
      {children}
    </ReportContext.Provider>
  )
}

export function useReport() {
  const context = useContext(ReportContext)
  if (!context) {
    throw new Error('useReport must be used within ReportProvider')
  }
  return context
}
```

### 4.4 组件集成示例

```typescript
// app/(dashboard)/reports/page.tsx
import { ReportProvider } from '@/contexts/report-context'
import { ReportFilters } from '@/components/reports/report-filters'
import { ReportStats } from '@/components/reports/report-stats'
// ... 其他组件导入

export default function ReportsPage() {
  return (
    <ReportProvider>
      <div className="space-y-6">
        <div>
          <h1 className="text-2xl font-bold text-[#333333]">报表中心</h1>
          <p className="text-sm text-[#6B7280] mt-1">查看营业数据和经营分析</p>
        </div>

        <ReportFilters />
        <ReportStats />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-2">
            <RevenueChart />
          </div>
          <div>
            <CategoryChart />
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <TopDishes />
          <HourlyAnalysis />
        </div>
      </div>
    </ReportProvider>
  )
}
```

---

## 5. 数据聚合逻辑

### 5.1 Prisma 查询优化

#### 使用索引加速查询

确保 `Order` 表有以下索引：

```prisma
model Order {
  // ... 其他字段
  createdAt  DateTime @default(now())

  @@index([createdAt])
  @@index([createdAt, isPaid])
  @@index([status, createdAt])
}
```

#### 复杂聚合查询示例

```typescript
// 按日期和分类聚合销售数据
const categorySalesByDate = await prisma.$queryRaw`
  SELECT
    DATE(o.createdAt) as date,
    c.id as categoryId,
    c.name as categoryName,
    SUM(oi.subtotal) as totalRevenue,
    SUM(oi.quantity) as totalQuantity
  FROM OrderItem oi
  JOIN \`Order\` o ON oi.orderId = o.id
  JOIN Dish d ON oi.dishId = d.id
  JOIN Category c ON d.categoryId = c.id
  WHERE
    o.createdAt >= ${startDate}
    AND o.createdAt <= ${endDate}
    AND o.isPaid = 1
  GROUP BY date, c.id, c.name
  ORDER BY date ASC, totalRevenue DESC
`
```

### 5.2 数据计算规则

#### 增长率计算

```typescript
function calculateGrowth(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0
  return ((current - previous) / previous) * 100
}
```

#### 百分比计算

```typescript
function calculatePercentage(part: number, total: number): number {
  if (total === 0) return 0
  return (part / total) * 100
}
```

#### 移动平均计算（用于趋势分析）

```typescript
function calculateMovingAverage(data: number[], window: number): number[] {
  const result: number[] = []

  for (let i = 0; i < data.length; i++) {
    const start = Math.max(0, i - window + 1)
    const slice = data.slice(start, i + 1)
    const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length
    result.push(avg)
  }

  return result
}
```

### 5.3 缓存策略

#### SWR 缓存配置

```typescript
// lib/swr-config.ts
export const swrConfig = {
  revalidateOnFocus: false,
  revalidateOnReconnect: true,
  refreshInterval: 60000, // 每分钟自动刷新
  dedupingInterval: 5000, // 5秒内去重
}

// 使用
const { data } = useSWR('/api/reports/overview', fetcher, swrConfig)
```

#### 服务端缓存（可选）

```typescript
// 使用 Next.js Route Handlers 缓存
export const revalidate = 300 // 5分钟缓存

// 或使用 Redis 缓存
import { redis } from '@/lib/redis'

async function getCachedReportData(key: string, ttl: number, generator: () => Promise<any>) {
  const cached = await redis.get(key)
  if (cached) return JSON.parse(cached)

  const data = await generator()
  await redis.setex(key, ttl, JSON.stringify(data))
  return data
}
```

---

## 6. 筛选器实现

### 6.1 日期范围处理

```typescript
// components/reports/report-filters.tsx
'use client'

import { useState } from 'react'
import { useReport } from '@/contexts/report-context'
import { getDateRange, getComparisonRange } from '@/lib/date-utils'

export function ReportFilters() {
  const { setFilters } = useReport()
  const [dateRange, setDateRange] = useState('today')

  const handleDateRangeChange = (value: string) => {
    setDateRange(value)

    const { start, end } = getDateRange(value)
    const { start: compareStart, end: compareEnd } = getComparisonRange(value)

    setFilters({
      startDate: start.toISOString(),
      endDate: end.toISOString(),
      compareStartDate: compareStart.toISOString(),
      compareEndDate: compareEnd.toISOString(),
      reportType: 'all',
    })
  }

  return (
    <Select value={dateRange} onValueChange={handleDateRangeChange}>
      {/* ... */}
    </Select>
  )
}
```

### 6.2 动态查询构建

```typescript
// lib/query-builder.ts
export function buildReportQuery(filters: ReportFilters) {
  const where: any = {
    createdAt: {
      gte: new Date(filters.startDate),
      lte: new Date(filters.endDate),
    },
    isPaid: true,
  }

  // 根据报表类型添加额外条件
  if (filters.reportType === 'revenue') {
    // 只查询营业额相关
  } else if (filters.reportType === 'dishes') {
    // 只查询菜品相关
  }

  return where
}
```

### 6.3 参数传递方案

使用 URL 查询参数保持状态：

```typescript
// 使用 Next.js useSearchParams
'use client'

import { useSearchParams, useRouter } from 'next/navigation'

export function ReportFilters() {
  const router = useRouter()
  const searchParams = useSearchParams()

  const updateFilters = (newFilters: Partial<ReportFilters>) => {
    const params = new URLSearchParams(searchParams)

    Object.entries(newFilters).forEach(([key, value]) => {
      if (value) params.set(key, value)
      else params.delete(key)
    })

    router.push(`/reports?${params.toString()}`)
  }

  // ...
}
```

---

## 7. 图表配置

### 7.1 Recharts 配置详解

#### 柱状图（营业额趋势）

```typescript
<BarChart data={data}>
  <CartesianGrid
    strokeDasharray="3 3"
    stroke="#E0E6ED"
    vertical={false}
  />

  <XAxis
    dataKey="date"
    stroke="#6B7280"
    fontSize={12}
    tickLine={false}
    axisLine={false}
    tickFormatter={(value) => format(new Date(value), 'MM/dd')}
  />

  <YAxis
    yAxisId="left"
    stroke="#6B7280"
    fontSize={12}
    tickLine={false}
    axisLine={false}
    tickFormatter={(value) => `¥${value / 1000}k`}
  />

  <Tooltip
    contentStyle={{
      backgroundColor: '#FFFFFF',
      border: '1px solid #E0E6ED',
      borderRadius: '8px',
      boxShadow: '0 2px 6px rgba(0,0,0,0.05)',
    }}
    formatter={(value: number, name: string) => {
      if (name === 'revenue') return [`¥${value.toLocaleString()}`, '营业额']
      if (name === 'orders') return [value, '订单数']
      return [value, name]
    }}
  />

  <Legend
    wrapperStyle={{ paddingTop: '20px' }}
    iconType="circle"
  />

  <Bar
    yAxisId="left"
    dataKey="revenue"
    fill="#1E90FF"
    radius={[4, 4, 0, 0]}
    animationDuration={800}
  />
</BarChart>
```

#### 饼图（分类占比）

```typescript
<PieChart>
  <Pie
    data={data}
    cx="50%"
    cy="50%"
    labelLine={false}
    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
    outerRadius={100}
    innerRadius={60} // 环形图
    fill="#8884d8"
    dataKey="value"
    animationBegin={0}
    animationDuration={800}
  >
    {data.map((entry, index) => (
      <Cell key={`cell-${index}`} fill={entry.color} />
    ))}
  </Pie>

  <Tooltip
    formatter={(value: number) => [`¥${value.toLocaleString()}`, '销售额']}
  />
</PieChart>
```

### 7.2 颜色主题规范

```typescript
// lib/chart-colors.ts
export const CHART_COLORS = {
  primary: '#1E90FF',      // 蓝色 - 主色
  success: '#28C76F',      // 绿色 - 成功/增长
  warning: '#FFB400',      // 黄色 - 警告
  danger: '#EA5455',       // 红色 - 错误/下降
  secondary: '#5A6B7B',    // 灰色 - 次要信息

  // 分类颜色（用于饼图等）
  categories: [
    '#1E90FF',
    '#28C76F',
    '#FFB400',
    '#5A6B7B',
    '#EA5455',
    '#00CFE8',
    '#7367F0',
  ],
}

// 根据增长率返回颜色
export function getGrowthColor(growth: number): string {
  if (growth > 0) return CHART_COLORS.success
  if (growth < 0) return CHART_COLORS.danger
  return CHART_COLORS.secondary
}
```

### 7.3 响应式设计

```typescript
// 使用 ResponsiveContainer 实现响应式
<ResponsiveContainer width="100%" height={320}>
  <BarChart data={data}>
    {/* ... */}
  </BarChart>
</ResponsiveContainer>

// 移动端优化
const isMobile = useMediaQuery('(max-width: 768px)')

<ResponsiveContainer width="100%" height={isMobile ? 250 : 320}>
  {/* ... */}
</ResponsiveContainer>
```

---

## 8. 导出功能

### 8.1 Excel 导出

安装依赖：

```bash
pnpm add xlsx
pnpm add -D @types/node
```

实现导出工具：

```typescript
// lib/export-excel.ts
import * as XLSX from 'xlsx'
import type { ReportOverview } from '@/types/reports'

export function exportToExcel(data: ReportOverview, filename: string) {
  // 创建工作簿
  const wb = XLSX.utils.book_new()

  // 1. 核心统计表
  const statsData = [
    ['指标', '数值', '增长率'],
    ['总营业额', `¥${data.stats.totalRevenue}`, `${data.stats.comparison?.revenueGrowth || 0}%`],
    ['订单总数', data.stats.totalOrders, `${data.stats.comparison?.ordersGrowth || 0}%`],
    ['客单价', `¥${data.stats.avgOrderValue}`, `${data.stats.comparison?.avgOrderGrowth || 0}%`],
    ['利润率', `${data.stats.profitRate}%`, '-'],
  ]
  const statsSheet = XLSX.utils.aoa_to_sheet(statsData)
  XLSX.utils.book_append_sheet(wb, statsSheet, '核心统计')

  // 2. 营业额趋势表
  const revenueData = [
    ['日期', '营业额', '订单数', '客单价'],
    ...data.revenueChart.map(item => [
      item.date,
      item.revenue,
      item.orders,
      item.avgOrder,
    ]),
  ]
  const revenueSheet = XLSX.utils.aoa_to_sheet(revenueData)
  XLSX.utils.book_append_sheet(wb, revenueSheet, '营业额趋势')

  // 3. 热销菜品表
  const dishesData = [
    ['排名', '菜品名称', '销量', '营业额', '增长率'],
    ...data.topDishes.map((item, index) => [
      index + 1,
      item.dishName,
      item.sales,
      item.revenue,
      `${item.growth}%`,
    ]),
  ]
  const dishesSheet = XLSX.utils.aoa_to_sheet(dishesData)
  XLSX.utils.book_append_sheet(wb, dishesSheet, '热销菜品')

  // 导出文件
  XLSX.writeFile(wb, `${filename}.xlsx`)
}
```

### 8.2 PDF 导出

安装依赖：

```bash
pnpm add jspdf jspdf-autotable
pnpm add -D @types/jspdf
```

实现导出工具：

```typescript
// lib/export-pdf.ts
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import type { ReportOverview } from '@/types/reports'

export function exportToPDF(data: ReportOverview, filename: string) {
  const doc = new jsPDF()

  // 添加中文字体支持（需要额外配置）
  // doc.addFont('path/to/font.ttf', 'CustomFont', 'normal')
  // doc.setFont('CustomFont')

  // 标题
  doc.setFontSize(18)
  doc.text('营业报表', 14, 20)

  // 日期范围
  doc.setFontSize(10)
  doc.text(`生成时间: ${new Date().toLocaleString('zh-CN')}`, 14, 30)

  // 核心统计表
  autoTable(doc, {
    startY: 40,
    head: [['指标', '数值', '增长率']],
    body: [
      ['总营业额', `¥${data.stats.totalRevenue}`, `${data.stats.comparison?.revenueGrowth || 0}%`],
      ['订单总数', data.stats.totalOrders.toString(), `${data.stats.comparison?.ordersGrowth || 0}%`],
      ['客单价', `¥${data.stats.avgOrderValue}`, `${data.stats.comparison?.avgOrderGrowth || 0}%`],
    ],
  })

  // 热销菜品表
  autoTable(doc, {
    startY: (doc as any).lastAutoTable.finalY + 10,
    head: [['排名', '菜品名称', '销量', '营业额']],
    body: data.topDishes.map((item, index) => [
      (index + 1).toString(),
      item.dishName,
      item.sales.toString(),
      `¥${item.revenue}`,
    ]),
  })

  // 保存 PDF
  doc.save(`${filename}.pdf`)
}
```

### 8.3 导出按钮实现

```typescript
// components/reports/export-buttons.tsx
'use client'

import { Download } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { useReport } from '@/contexts/report-context'
import { exportToExcel } from '@/lib/export-excel'
import { exportToPDF } from '@/lib/export-pdf'
import { toast } from 'sonner'

export function ExportButtons() {
  const { data } = useReport()

  const handleExportExcel = () => {
    if (!data) {
      toast.error('暂无数据可导出')
      return
    }

    try {
      const filename = `营业报表_${new Date().toISOString().split('T')[0]}`
      exportToExcel(data, filename)
      toast.success('Excel 导出成功')
    } catch (error) {
      toast.error('导出失败，请重试')
    }
  }

  const handleExportPDF = () => {
    if (!data) {
      toast.error('暂无数据可导出')
      return
    }

    try {
      const filename = `营业报表_${new Date().toISOString().split('T')[0]}`
      exportToPDF(data, filename)
      toast.success('PDF 导出成功')
    } catch (error) {
      toast.error('导出失败，请重试')
    }
  }

  return (
    <div className="flex gap-2">
      <Button
        variant="outline"
        onClick={handleExportExcel}
        disabled={!data}
      >
        <Download className="h-4 w-4 mr-2" />
        导出 Excel
      </Button>

      <Button
        variant="outline"
        onClick={handleExportPDF}
        disabled={!data}
      >
        <Download className="h-4 w-4 mr-2" />
        导出 PDF
      </Button>
    </div>
  )
}
```

---

## 9. 性能优化

### 9.1 数据库索引建议

```prisma
// prisma/schema.prisma

model Order {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  isPaid     Boolean  @default(false)
  status     String

  // 添加复合索引提升查询性能
  @@index([createdAt, isPaid])
  @@index([status, createdAt])
  @@index([isPaid, status, createdAt])
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  dishId    String
  createdAt DateTime @default(now())

  @@index([dishId, createdAt])
  @@index([orderId, dishId])
}
```

### 9.2 分页与懒加载

```typescript
// 使用游标分页优化大数据量查询
async function getPaginatedOrders(cursor?: string, limit: number = 50) {
  return await prisma.order.findMany({
    take: limit,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: 'desc' },
  })
}

// 前端使用 SWR Infinite 实现无限滚动
import useSWRInfinite from 'swr/infinite'

const getKey = (pageIndex: number, previousPageData: any) => {
  if (previousPageData && !previousPageData.hasMore) return null
  return `/api/reports/orders?page=${pageIndex}`
}

const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
```

### 9.3 缓存机制

#### 使用 React Query（替代方案）

```typescript
// 如果使用 React Query 代替 SWR
import { useQuery } from '@tanstack/react-query'

export function useReportData(filters: ReportFilters) {
  return useQuery({
    queryKey: ['reports', filters],
    queryFn: () => fetchReportData(filters),
    staleTime: 5 * 60 * 1000, // 5分钟内数据视为新鲜
    cacheTime: 10 * 60 * 1000, // 缓存10分钟
  })
}
```

#### 服务端缓存

```typescript
// 使用 Next.js 内置缓存
export const revalidate = 300 // 5分钟

// 或使用 unstable_cache
import { unstable_cache } from 'next/cache'

const getCachedReportData = unstable_cache(
  async (startDate: string, endDate: string) => {
    return await getReportStats(new Date(startDate), new Date(endDate))
  },
  ['report-stats'],
  { revalidate: 300, tags: ['reports'] }
)
```

### 9.4 查询优化技巧

```typescript
// 1. 使用 select 只查询需要的字段
const orders = await prisma.order.findMany({
  select: {
    id: true,
    totalPrice: true,
    createdAt: true,
  },
})

// 2. 使用 parallel queries 并行查询
const [stats, topDishes, hourlyData] = await Promise.all([
  getReportStats(startDate, endDate),
  getTopDishes(startDate, endDate, 5),
  getHourlyAnalysis(startDate, endDate),
])

// 3. 使用 aggregation 代替多次查询
const stats = await prisma.order.aggregate({
  where: { isPaid: true },
  _sum: { totalPrice: true },
  _count: true,
  _avg: { totalPrice: true },
})
```

---

## 10. 使用示例

### 10.1 API 调用示例

#### 获取综合报表

```typescript
// 获取今日报表
const response = await fetch('/api/reports/overview?' + new URLSearchParams({
  startDate: new Date(new Date().setHours(0,0,0,0)).toISOString(),
  endDate: new Date().toISOString(),
}))

const { success, data } = await response.json()

if (success) {
  console.log('营业额:', data.stats.totalRevenue)
  console.log('订单数:', data.stats.totalOrders)
}
```

#### 获取本周报表（含对比）

```typescript
import { startOfWeek, endOfWeek, subWeeks } from 'date-fns'

const thisWeekStart = startOfWeek(new Date(), { weekStartsOn: 1 })
const thisWeekEnd = endOfWeek(new Date(), { weekStartsOn: 1 })
const lastWeekStart = startOfWeek(subWeeks(new Date(), 1), { weekStartsOn: 1 })
const lastWeekEnd = endOfWeek(subWeeks(new Date(), 1), { weekStartsOn: 1 })

const response = await fetch('/api/reports/overview?' + new URLSearchParams({
  startDate: thisWeekStart.toISOString(),
  endDate: thisWeekEnd.toISOString(),
  compareStartDate: lastWeekStart.toISOString(),
  compareEndDate: lastWeekEnd.toISOString(),
}))
```

### 10.2 组件集成示例

#### 在页面中使用报表组件

```typescript
// app/(dashboard)/reports/page.tsx
import { Suspense } from 'react'
import { ReportProvider } from '@/contexts/report-context'
import { ReportFilters } from '@/components/reports/report-filters'
import { ReportStats } from '@/components/reports/report-stats'
import { Skeleton } from '@/components/ui/skeleton'

export default function ReportsPage() {
  return (
    <ReportProvider>
      <div className="space-y-6">
        <PageHeader />

        <Suspense fallback={<Skeleton className="h-20" />}>
          <ReportFilters />
        </Suspense>

        <Suspense fallback={<Skeleton className="h-40" />}>
          <ReportStats />
        </Suspense>

        <ChartsSection />
        <TablesSection />
      </div>
    </ReportProvider>
  )
}
```

#### 自定义报表组件

```typescript
// components/custom/monthly-revenue.tsx
'use client'

import { useReport } from '@/contexts/report-context'
import { Card } from '@/components/ui/card'
import { formatCurrency } from '@/lib/utils'

export function MonthlyRevenue() {
  const { data, isLoading } = useReport()

  if (isLoading) return <Card className="p-6">加载中...</Card>
  if (!data) return null

  const monthlyRevenue = data.revenueChart.reduce(
    (sum, item) => sum + item.revenue,
    0
  )

  return (
    <Card className="p-6">
      <h3 className="text-lg font-semibold">本月营业额</h3>
      <p className="text-3xl font-bold text-[#1E90FF] mt-2">
        {formatCurrency(monthlyRevenue)}
      </p>
    </Card>
  )
}
```

### 10.3 常见问题解答

#### Q1: 如何更改报表的默认日期范围？

```typescript
// 在 ReportProvider 中修改初始状态
const [filters, setFilters] = useState<ReportFilters>({
  startDate: startOfMonth(new Date()).toISOString(), // 改为本月开始
  endDate: new Date().toISOString(),
  reportType: 'all',
})
```

#### Q2: 如何添加新的统计指标？

1. 在 `types/reports.ts` 中添加新字段
2. 在 API 中实现计算逻辑
3. 在 `ReportStats` 组件中添加新卡片

```typescript
// types/reports.ts
export interface ReportStats {
  // ... 现有字段
  customerCount: number  // 新增：客户数
}

// API 中计算
const customerCount = await prisma.order.groupBy({
  by: ['userId'],
  where: { /* ... */ },
  _count: true,
})

// 组件中显示
<StatCard
  title="客户数"
  value={stats.customerCount}
  icon={Users}
  color="#1E90FF"
/>
```

#### Q3: 如何优化大数据量的报表性能？

1. **使用数据库索引**（见 9.1 节）
2. **实现分页加载**（见 9.2 节）
3. **启用缓存**（见 9.3 节）
4. **使用 SQL 聚合代替应用层计算**

```typescript
// ❌ 不推荐：应用层计算
const orders = await prisma.order.findMany({ where: { isPaid: true } })
const total = orders.reduce((sum, o) => sum + o.totalPrice, 0)

// ✅ 推荐：数据库聚合
const { _sum } = await prisma.order.aggregate({
  where: { isPaid: true },
  _sum: { totalPrice: true },
})
```

#### Q4: 如何实现实时数据更新？

使用 SWR 的自动重新验证功能：

```typescript
const { data } = useSWR('/api/reports/overview', fetcher, {
  refreshInterval: 30000, // 每30秒自动刷新
  revalidateOnFocus: true, // 窗口聚焦时刷新
})
```

或使用 WebSocket 推送（更高级）：

```typescript
// 建立 WebSocket 连接
const ws = new WebSocket('ws://localhost:3000/api/ws')

ws.onmessage = (event) => {
  const newData = JSON.parse(event.data)
  mutate('/api/reports/overview', newData, false)
}
```

---

## 11. 总结

### 11.1 已实现功能

✅ 完整的前端报表组件体系
✅ 数据可视化（柱状图、饼图、表格）
✅ 响应式设计和移动端适配
✅ 统一的 UI 风格和交互体验

### 11.2 待实现功能

⏳ 后端 API 路由实现
⏳ 数据库查询优化
⏳ Excel/PDF 导出功能
⏳ 实时数据推送
⏳ 高级筛选和自定义报表

### 11.3 扩展建议

1. **移动端专属报表** - 设计更适合手机查看的报表界面
2. **自定义报表模板** - 允许用户保存常用的报表配置
3. **邮件订阅** - 定时发送报表到邮箱
4. **对比分析** - 多时段、多维度的对比分析
5. **预测分析** - 基于历史数据的销售预测
6. **多门店支持** - 支持多门店的数据汇总和对比

---

## 附录

### A. 相关文件清单

| 文件路径 | 说明 |
|---------|------|
| `app/(dashboard)/reports/page.tsx` | 报表页面主文件 |
| `components/reports/report-filters.tsx` | 筛选器组件 |
| `components/reports/report-stats.tsx` | 统计卡片组件 |
| `components/reports/revenue-chart.tsx` | 营业额图表组件 |
| `components/reports/category-chart.tsx` | 分类图表组件 |
| `components/reports/top-dishes.tsx` | 热销菜品组件 |
| `components/reports/hourly-analysis.tsx` | 时段分析组件 |
| `types/reports.ts` | 报表类型定义 |
| `lib/report-utils.ts` | 报表工具函数 |
| `lib/date-utils.ts` | 日期处理工具 |
| `contexts/report-context.tsx` | 报表上下文 |

### B. 技术栈版本

- Next.js: 15.2.4
- React: 19
- TypeScript: 5.x
- Prisma: 6.16.3
- Recharts: latest
- date-fns: 4.1.0
- SWR: 2.3.6
- xlsx: (待安装)
- jspdf: (待安装)

### C. 参考资源

- [Recharts 官方文档](https://recharts.org/)
- [Prisma Aggregation 文档](https://www.prisma.io/docs/concepts/components/prisma-client/aggregation-grouping-summarizing)
- [SWR 官方文档](https://swr.vercel.app/)
- [date-fns 文档](https://date-fns.org/)

---

**文档版本**: v1.0
**最后更新**: 2025-10-07
**维护者**: 开发团队
