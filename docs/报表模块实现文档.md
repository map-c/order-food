# ğŸ“Š æŠ¥è¡¨æ¨¡å—å®ç°æ–‡æ¡£

## 1. æ¨¡å—æ¦‚è¿°

### 1.1 åŠŸèƒ½ç®€ä»‹

æŠ¥è¡¨æ¨¡å—æ˜¯é¤é¦†ç‚¹é¤ç³»ç»Ÿçš„æ ¸å¿ƒæ•°æ®åˆ†æåŠŸèƒ½ï¼Œä¸ºåº—ä¸»å’Œç®¡ç†äººå‘˜æä¾›å…¨é¢çš„ç»è¥æ•°æ®æ´å¯Ÿã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬ï¼š

- **ç»¼åˆç»Ÿè®¡** - è¥ä¸šé¢ã€è®¢å•æ•°ã€å®¢å•ä»·ã€åˆ©æ¶¦ç‡ç­‰æ ¸å¿ƒæŒ‡æ ‡
- **è¶‹åŠ¿åˆ†æ** - è¥ä¸šé¢ä¸è®¢å•æ•°è¶‹åŠ¿å›¾è¡¨
- **åˆ†ç±»åˆ†æ** - å„ç±»èœå“é”€å”®é¢å æ¯”
- **çƒ­é”€åˆ†æ** - çƒ­é”€èœå“ TOP æ’è¡Œæ¦œ
- **æ—¶æ®µåˆ†æ** - ä¸åŒæ—¶æ®µçš„è¥ä¸šæ•°æ®å¯¹æ¯”
- **æ•°æ®å¯¼å‡º** - æ”¯æŒ Excel å’Œ PDF æ ¼å¼å¯¼å‡º

### 1.2 æŠ€æœ¯æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     æŠ¥è¡¨é¡µé¢ (/reports)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ReportFiltersâ”‚  â”‚  ReportStats â”‚  â”‚ RevenueChart â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚CategoryChart â”‚  â”‚  TopDishes   â”‚  â”‚HourlyAnalysisâ”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  SWR æ•°æ®è·å–  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åç«¯ API è·¯ç”±                          â”‚
â”‚  /api/reports/overview   - ç»¼åˆæŠ¥è¡¨æ•°æ®                   â”‚
â”‚  /api/reports/revenue    - è¥ä¸šé¢æŠ¥è¡¨                     â”‚
â”‚  /api/reports/dishes     - èœå“é”€å”®æŠ¥è¡¨                   â”‚
â”‚  /api/reports/hourly     - æ—¶æ®µåˆ†ææŠ¥è¡¨                   â”‚
â”‚  /api/reports/export     - æ•°æ®å¯¼å‡º                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  Prisma ORM   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚  SQLite DB    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 æ ¸å¿ƒæŒ‡æ ‡è¯´æ˜

| æŒ‡æ ‡åç§° | è®¡ç®—å…¬å¼ | è¯´æ˜ |
|---------|---------|------|
| **æ€»è¥ä¸šé¢** | `SUM(totalPrice) WHERE isPaid = true` | å·²æ”¯ä»˜è®¢å•çš„æ€»é‡‘é¢ |
| **è®¢å•æ€»æ•°** | `COUNT(*) WHERE status = 'completed'` | å·²å®Œæˆçš„è®¢å•æ•°é‡ |
| **å®¢å•ä»·** | `æ€»è¥ä¸šé¢ / è®¢å•æ€»æ•°` | å¹³å‡æ¯å•æ¶ˆè´¹é‡‘é¢ |
| **åˆ©æ¶¦ç‡** | `(è¥ä¸šé¢ - æˆæœ¬) / è¥ä¸šé¢ Ã— 100%` | æ¯›åˆ©æ¶¦å æ¯”ï¼ˆéœ€æˆæœ¬æ•°æ®ï¼‰ |
| **å¢é•¿ç‡** | `(å½“å‰å€¼ - å¯¹æ¯”å€¼) / å¯¹æ¯”å€¼ Ã— 100%` | ä¸ä¸ŠæœŸå¯¹æ¯”çš„å¢é•¿ç™¾åˆ†æ¯” |

---

## 2. æ•°æ®æ¨¡å‹è®¾è®¡

### 2.1 æŠ¥è¡¨æ•°æ®ç»“æ„

```typescript
// types/reports.ts

/**
 * æŠ¥è¡¨ç­›é€‰å‚æ•°
 */
export interface ReportFilters {
  startDate: string        // å¼€å§‹æ—¥æœŸ ISO 8601 æ ¼å¼
  endDate: string          // ç»“æŸæ—¥æœŸ
  compareStartDate?: string // å¯¹æ¯”æœŸå¼€å§‹æ—¥æœŸï¼ˆç”¨äºè®¡ç®—å¢é•¿ç‡ï¼‰
  compareEndDate?: string   // å¯¹æ¯”æœŸç»“æŸæ—¥æœŸ
  reportType?: 'all' | 'revenue' | 'dishes' | 'hourly'
}

/**
 * æ ¸å¿ƒç»Ÿè®¡æ•°æ®
 */
export interface ReportStats {
  totalRevenue: number      // æ€»è¥ä¸šé¢
  totalOrders: number       // è®¢å•æ€»æ•°
  avgOrderValue: number     // å®¢å•ä»·
  profitRate: number        // åˆ©æ¶¦ç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
  comparison?: {
    revenueGrowth: number   // è¥ä¸šé¢å¢é•¿ç‡
    ordersGrowth: number    // è®¢å•å¢é•¿ç‡
    avgOrderGrowth: number  // å®¢å•ä»·å¢é•¿ç‡
  }
}

/**
 * è¥ä¸šé¢è¶‹åŠ¿æ•°æ®ç‚¹
 */
export interface RevenueDataPoint {
  date: string              // æ—¥æœŸ
  revenue: number           // è¥ä¸šé¢
  orders: number            // è®¢å•æ•°
  avgOrder: number          // å®¢å•ä»·
}

/**
 * åˆ†ç±»é”€å”®æ•°æ®
 */
export interface CategorySales {
  categoryId: string
  categoryName: string
  totalRevenue: number
  totalOrders: number
  percentage: number        // å æ€»è¥ä¸šé¢çš„ç™¾åˆ†æ¯”
}

/**
 * çƒ­é”€èœå“æ•°æ®
 */
export interface TopDishData {
  dishId: string
  dishName: string
  categoryName: string
  sales: number             // é”€é‡
  revenue: number           // è¥ä¸šé¢
  growth: number            // å¢é•¿ç‡
}

/**
 * æ—¶æ®µåˆ†ææ•°æ®
 */
export interface HourlyData {
  timeRange: string         // æ—¶é—´æ®µï¼Œå¦‚ "11:00-12:00"
  orders: number            // è®¢å•æ•°
  revenue: number           // è¥ä¸šé¢
  avgOrder: number          // å®¢å•ä»·
}

/**
 * ç»¼åˆæŠ¥è¡¨å“åº”
 */
export interface ReportOverview {
  stats: ReportStats
  revenueChart: RevenueDataPoint[]
  categoryChart: CategorySales[]
  topDishes: TopDishData[]
  hourlyAnalysis: HourlyData[]
}
```

### 2.2 ç»Ÿè®¡ç»´åº¦å®šä¹‰

#### æ—¶é—´ç»´åº¦
- **ä»Šå¤©** - å½“å¤© 00:00 è‡³å½“å‰æ—¶é—´
- **æ˜¨å¤©** - æ˜¨å¤© 00:00 è‡³ 23:59
- **æœ¬å‘¨** - æœ¬å‘¨ä¸€ 00:00 è‡³å½“å‰æ—¶é—´
- **æœ¬æœˆ** - æœ¬æœˆ 1 æ—¥ 00:00 è‡³å½“å‰æ—¶é—´
- **æœ¬å­£åº¦** - æœ¬å­£åº¦ç¬¬ä¸€å¤© 00:00 è‡³å½“å‰æ—¶é—´
- **æœ¬å¹´** - 1 æœˆ 1 æ—¥ 00:00 è‡³å½“å‰æ—¶é—´
- **è‡ªå®šä¹‰** - ç”¨æˆ·æŒ‡å®šçš„æ—¥æœŸèŒƒå›´

#### å¯¹æ¯”ç»´åº¦
- **ç¯æ¯”** - ä¸ä¸Šä¸€ä¸ªç›¸åŒæ—¶é—´æ®µå¯¹æ¯”ï¼ˆå¦‚æœ¬å‘¨ vs ä¸Šå‘¨ï¼‰
- **åŒæ¯”** - ä¸å»å¹´åŒæœŸå¯¹æ¯”ï¼ˆå¦‚æœ¬æœˆ vs å»å¹´æœ¬æœˆï¼‰

### 2.3 æ—¶é—´ç»´åº¦å¤„ç†

ä½¿ç”¨ `date-fns` åº“è¿›è¡Œæ—¥æœŸå¤„ç†ï¼š

```typescript
import {
  startOfDay,
  endOfDay,
  startOfWeek,
  endOfWeek,
  startOfMonth,
  endOfMonth,
  subDays,
  subWeeks,
  subMonths,
  format
} from 'date-fns'

export function getDateRange(range: string): { start: Date; end: Date } {
  const now = new Date()

  switch (range) {
    case 'today':
      return { start: startOfDay(now), end: now }

    case 'yesterday':
      const yesterday = subDays(now, 1)
      return { start: startOfDay(yesterday), end: endOfDay(yesterday) }

    case 'week':
      return { start: startOfWeek(now, { weekStartsOn: 1 }), end: now }

    case 'month':
      return { start: startOfMonth(now), end: now }

    default:
      return { start: startOfDay(now), end: now }
  }
}

export function getComparisonRange(range: string): { start: Date; end: Date } {
  const { start, end } = getDateRange(range)
  const duration = end.getTime() - start.getTime()

  const compareEnd = new Date(start.getTime() - 1)
  const compareStart = new Date(compareEnd.getTime() - duration)

  return { start: compareStart, end: compareEnd }
}
```

---

## 3. åç«¯ API è®¾è®¡

### 3.1 API ç«¯ç‚¹åˆ—è¡¨

| ç«¯ç‚¹ | æ–¹æ³• | è¯´æ˜ | æŸ¥è¯¢å‚æ•° |
|------|------|------|---------|
| `/api/reports/overview` | GET | è·å–ç»¼åˆæŠ¥è¡¨æ•°æ® | `startDate`, `endDate`, `compareStartDate`, `compareEndDate` |
| `/api/reports/revenue` | GET | è·å–è¥ä¸šé¢æŠ¥è¡¨ | åŒä¸Š + `granularity` (hour/day/month) |
| `/api/reports/dishes` | GET | è·å–èœå“é”€å”®æŠ¥è¡¨ | åŒä¸Š + `limit`, `categoryId` |
| `/api/reports/hourly` | GET | è·å–æ—¶æ®µåˆ†ææŠ¥è¡¨ | `startDate`, `endDate` |
| `/api/reports/export` | POST | å¯¼å‡ºæŠ¥è¡¨æ•°æ® | `format` (excel/pdf), `reportType` |

### 3.2 ç»Ÿä¸€å“åº”æ ¼å¼

```typescript
// æˆåŠŸå“åº”
{
  success: true,
  data: T,
  message?: string
}

// é”™è¯¯å“åº”
{
  success: false,
  error: {
    code: string,
    message: string
  }
}
```

### 3.3 API å®ç°ç¤ºä¾‹

#### 3.3.1 ç»¼åˆæŠ¥è¡¨ API

```typescript
// app/api/reports/overview/route.ts
import { NextRequest } from 'next/server'
import { z } from 'zod'
import { prisma } from '@/lib/prisma'
import { apiResponse } from '@/lib/api-response'
import type { ReportOverview } from '@/types/reports'

const querySchema = z.object({
  startDate: z.string().datetime(),
  endDate: z.string().datetime(),
  compareStartDate: z.string().datetime().optional(),
  compareEndDate: z.string().datetime().optional(),
})

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)

    const params = {
      startDate: searchParams.get('startDate'),
      endDate: searchParams.get('endDate'),
      compareStartDate: searchParams.get('compareStartDate'),
      compareEndDate: searchParams.get('compareEndDate'),
    }

    // éªŒè¯å‚æ•°
    const validationResult = querySchema.safeParse(params)
    if (!validationResult.success) {
      return apiResponse.error(
        'å‚æ•°éªŒè¯å¤±è´¥',
        'VALIDATION_ERROR',
        400
      )
    }

    const { startDate, endDate, compareStartDate, compareEndDate } = validationResult.data

    // 1. è·å–æ ¸å¿ƒç»Ÿè®¡æ•°æ®
    const stats = await getReportStats(
      new Date(startDate),
      new Date(endDate),
      compareStartDate ? new Date(compareStartDate) : undefined,
      compareEndDate ? new Date(compareEndDate) : undefined
    )

    // 2. è·å–è¥ä¸šé¢è¶‹åŠ¿æ•°æ®
    const revenueChart = await getRevenueChart(
      new Date(startDate),
      new Date(endDate)
    )

    // 3. è·å–åˆ†ç±»é”€å”®æ•°æ®
    const categoryChart = await getCategoryChart(
      new Date(startDate),
      new Date(endDate)
    )

    // 4. è·å–çƒ­é”€èœå“æ•°æ®
    const topDishes = await getTopDishes(
      new Date(startDate),
      new Date(endDate),
      5 // TOP 5
    )

    // 5. è·å–æ—¶æ®µåˆ†ææ•°æ®
    const hourlyAnalysis = await getHourlyAnalysis(
      new Date(startDate),
      new Date(endDate)
    )

    const data: ReportOverview = {
      stats,
      revenueChart,
      categoryChart,
      topDishes,
      hourlyAnalysis,
    }

    return apiResponse.success(data)
  } catch (error) {
    console.error('Get report overview error:', error)
    return apiResponse.error(
      'è·å–æŠ¥è¡¨æ•°æ®å¤±è´¥',
      'INTERNAL_ERROR',
      500
    )
  }
}

/**
 * è·å–æ ¸å¿ƒç»Ÿè®¡æ•°æ®
 */
async function getReportStats(
  startDate: Date,
  endDate: Date,
  compareStartDate?: Date,
  compareEndDate?: Date
) {
  // å½“å‰æœŸé—´çš„ç»Ÿè®¡
  const currentStats = await prisma.order.aggregate({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    _sum: {
      totalPrice: true,
    },
    _count: true,
  })

  const totalRevenue = currentStats._sum.totalPrice || 0
  const totalOrders = currentStats._count
  const avgOrderValue = totalOrders > 0 ? totalRevenue / totalOrders : 0

  // å¦‚æœæœ‰å¯¹æ¯”æœŸï¼Œè®¡ç®—å¢é•¿ç‡
  let comparison
  if (compareStartDate && compareEndDate) {
    const compareStats = await prisma.order.aggregate({
      where: {
        createdAt: {
          gte: compareStartDate,
          lte: compareEndDate,
        },
        isPaid: true,
      },
      _sum: {
        totalPrice: true,
      },
      _count: true,
    })

    const compareRevenue = compareStats._sum.totalPrice || 0
    const compareOrders = compareStats._count
    const compareAvgOrder = compareOrders > 0 ? compareRevenue / compareOrders : 0

    comparison = {
      revenueGrowth: compareRevenue > 0
        ? ((totalRevenue - compareRevenue) / compareRevenue) * 100
        : 0,
      ordersGrowth: compareOrders > 0
        ? ((totalOrders - compareOrders) / compareOrders) * 100
        : 0,
      avgOrderGrowth: compareAvgOrder > 0
        ? ((avgOrderValue - compareAvgOrder) / compareAvgOrder) * 100
        : 0,
    }
  }

  return {
    totalRevenue,
    totalOrders,
    avgOrderValue,
    profitRate: 58.3, // TODO: éœ€è¦æˆæœ¬æ•°æ®è®¡ç®—çœŸå®åˆ©æ¶¦ç‡
    comparison,
  }
}

/**
 * è·å–è¥ä¸šé¢è¶‹åŠ¿æ•°æ®ï¼ˆæŒ‰å¤©èšåˆï¼‰
 */
async function getRevenueChart(startDate: Date, endDate: Date) {
  const orders = await prisma.order.groupBy({
    by: ['createdAt'],
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    _sum: {
      totalPrice: true,
    },
    _count: true,
  })

  // æŒ‰æ—¥æœŸèšåˆ
  const dailyData = new Map<string, { revenue: number; orders: number }>()

  orders.forEach((order) => {
    const date = order.createdAt.toISOString().split('T')[0]
    const existing = dailyData.get(date) || { revenue: 0, orders: 0 }

    dailyData.set(date, {
      revenue: existing.revenue + (order._sum.totalPrice || 0),
      orders: existing.orders + order._count,
    })
  })

  return Array.from(dailyData.entries()).map(([date, data]) => ({
    date,
    revenue: data.revenue,
    orders: data.orders,
    avgOrder: data.orders > 0 ? data.revenue / data.orders : 0,
  }))
}

/**
 * è·å–åˆ†ç±»é”€å”®æ•°æ®
 */
async function getCategoryChart(startDate: Date, endDate: Date) {
  const categoryStats = await prisma.orderItem.groupBy({
    by: ['dishId'],
    where: {
      order: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        isPaid: true,
      },
    },
    _sum: {
      subtotal: true,
      quantity: true,
    },
  })

  // è·å–èœå“å’Œåˆ†ç±»ä¿¡æ¯
  const dishIds = categoryStats.map(stat => stat.dishId)
  const dishes = await prisma.dish.findMany({
    where: { id: { in: dishIds } },
    include: { category: true },
  })

  // æŒ‰åˆ†ç±»èšåˆ
  const categoryMap = new Map<string, { name: string; revenue: number; orders: number }>()

  categoryStats.forEach((stat) => {
    const dish = dishes.find(d => d.id === stat.dishId)
    if (!dish) return

    const existing = categoryMap.get(dish.categoryId) || {
      name: dish.category.name,
      revenue: 0,
      orders: 0,
    }

    categoryMap.set(dish.categoryId, {
      name: existing.name,
      revenue: existing.revenue + (stat._sum.subtotal || 0),
      orders: existing.orders + (stat._sum.quantity || 0),
    })
  })

  const totalRevenue = Array.from(categoryMap.values())
    .reduce((sum, item) => sum + item.revenue, 0)

  return Array.from(categoryMap.entries()).map(([categoryId, data]) => ({
    categoryId,
    categoryName: data.name,
    totalRevenue: data.revenue,
    totalOrders: data.orders,
    percentage: totalRevenue > 0 ? (data.revenue / totalRevenue) * 100 : 0,
  }))
}

/**
 * è·å–çƒ­é”€èœå“æ•°æ®
 */
async function getTopDishes(startDate: Date, endDate: Date, limit: number) {
  const dishStats = await prisma.orderItem.groupBy({
    by: ['dishId'],
    where: {
      order: {
        createdAt: {
          gte: startDate,
          lte: endDate,
        },
        isPaid: true,
      },
    },
    _sum: {
      quantity: true,
      subtotal: true,
    },
    orderBy: {
      _sum: {
        quantity: 'desc',
      },
    },
    take: limit,
  })

  // è·å–èœå“è¯¦æƒ…
  const dishIds = dishStats.map(stat => stat.dishId)
  const dishes = await prisma.dish.findMany({
    where: { id: { in: dishIds } },
    include: { category: true },
  })

  // TODO: è®¡ç®—å¢é•¿ç‡éœ€è¦å¯¹æ¯”æœŸæ•°æ®

  return dishStats.map((stat, index) => {
    const dish = dishes.find(d => d.id === stat.dishId)
    return {
      dishId: stat.dishId,
      dishName: dish?.name || 'Unknown',
      categoryName: dish?.category.name || 'Unknown',
      sales: stat._sum.quantity || 0,
      revenue: stat._sum.subtotal || 0,
      growth: 0, // TODO: å®ç°å¢é•¿ç‡è®¡ç®—
    }
  })
}

/**
 * è·å–æ—¶æ®µåˆ†ææ•°æ®
 */
async function getHourlyAnalysis(startDate: Date, endDate: Date) {
  const orders = await prisma.order.findMany({
    where: {
      createdAt: {
        gte: startDate,
        lte: endDate,
      },
      isPaid: true,
    },
    select: {
      createdAt: true,
      totalPrice: true,
    },
  })

  // æŒ‰å°æ—¶èšåˆ
  const hourlyMap = new Map<number, { orders: number; revenue: number }>()

  orders.forEach((order) => {
    const hour = order.createdAt.getHours()
    const existing = hourlyMap.get(hour) || { orders: 0, revenue: 0 }

    hourlyMap.set(hour, {
      orders: existing.orders + 1,
      revenue: existing.revenue + order.totalPrice,
    })
  })

  // è½¬æ¢ä¸ºæ—¶é—´æ®µæ ¼å¼
  return Array.from(hourlyMap.entries())
    .map(([hour, data]) => ({
      timeRange: `${hour.toString().padStart(2, '0')}:00-${(hour + 1).toString().padStart(2, '0')}:00`,
      orders: data.orders,
      revenue: data.revenue,
      avgOrder: data.orders > 0 ? data.revenue / data.orders : 0,
    }))
    .sort((a, b) => parseInt(a.timeRange) - parseInt(b.timeRange))
}
```

---

## 4. å‰ç«¯ç»„ä»¶è¯´æ˜

### 4.1 ç»„ä»¶æ ‘ç»“æ„

```
ReportsPage (é¡µé¢)
â”œâ”€â”€ ReportFilters (ç­›é€‰å™¨)
â”‚   â”œâ”€â”€ DateRangePicker (æ—¥æœŸèŒƒå›´é€‰æ‹©å™¨)
â”‚   â”œâ”€â”€ ReportTypeSelector (æŠ¥è¡¨ç±»å‹é€‰æ‹©å™¨)
â”‚   â””â”€â”€ ExportButtons (å¯¼å‡ºæŒ‰é’®)
â”œâ”€â”€ ReportStats (ç»Ÿè®¡å¡ç‰‡)
â”‚   â””â”€â”€ StatCard Ã— 4 (å•ä¸ªç»Ÿè®¡å¡ç‰‡)
â”œâ”€â”€ RevenueChart (è¥ä¸šé¢è¶‹åŠ¿å›¾)
â”‚   â””â”€â”€ Recharts BarChart
â”œâ”€â”€ CategoryChart (åˆ†ç±»å æ¯”å›¾)
â”‚   â””â”€â”€ Recharts PieChart
â”œâ”€â”€ TopDishes (çƒ­é”€èœå“è¡¨æ ¼)
â”‚   â””â”€â”€ Table (shadcn/ui)
â””â”€â”€ HourlyAnalysis (æ—¶æ®µåˆ†æè¡¨æ ¼)
    â””â”€â”€ Table (shadcn/ui)
```

### 4.2 æ•°æ®æµå‘

```
ç”¨æˆ·äº¤äº’ï¼ˆé€‰æ‹©æ—¥æœŸèŒƒå›´ï¼‰
    â†“
ReportFilters æ›´æ–°çŠ¶æ€
    â†“
è§¦å‘ SWR é‡æ–°è¯·æ±‚
    â†“
è°ƒç”¨ /api/reports/overview
    â†“
Prisma æŸ¥è¯¢æ•°æ®åº“
    â†“
æ•°æ®èšåˆè®¡ç®—
    â†“
è¿”å› JSON å“åº”
    â†“
SWR ç¼“å­˜æ•°æ®
    â†“
å„ç»„ä»¶é‡æ–°æ¸²æŸ“
```

### 4.3 çŠ¶æ€ç®¡ç†æ–¹æ¡ˆ

ä½¿ç”¨ React Context + SWR è¿›è¡ŒçŠ¶æ€ç®¡ç†ï¼š

```typescript
// contexts/report-context.tsx
'use client'

import { createContext, useContext, useState, ReactNode } from 'react'
import useSWR from 'swr'
import { fetcher } from '@/lib/api-client'
import type { ReportFilters, ReportOverview } from '@/types/reports'

interface ReportContextType {
  filters: ReportFilters
  setFilters: (filters: ReportFilters) => void
  data?: ReportOverview
  isLoading: boolean
  error: any
}

const ReportContext = createContext<ReportContextType | undefined>(undefined)

export function ReportProvider({ children }: { children: ReactNode }) {
  const [filters, setFilters] = useState<ReportFilters>({
    startDate: new Date().toISOString(),
    endDate: new Date().toISOString(),
    reportType: 'all',
  })

  // æ„å»ºæŸ¥è¯¢å‚æ•°
  const queryParams = new URLSearchParams({
    startDate: filters.startDate,
    endDate: filters.endDate,
    ...(filters.compareStartDate && { compareStartDate: filters.compareStartDate }),
    ...(filters.compareEndDate && { compareEndDate: filters.compareEndDate }),
  })

  const { data, error, isLoading } = useSWR<ReportOverview>(
    `/api/reports/overview?${queryParams}`,
    fetcher
  )

  return (
    <ReportContext.Provider value={{ filters, setFilters, data, isLoading, error }}>
      {children}
    </ReportContext.Provider>
  )
}

export function useReport() {
  const context = useContext(ReportContext)
  if (!context) {
    throw new Error('useReport must be used within ReportProvider')
  }
  return context
}
```

### 4.4 ç»„ä»¶é›†æˆç¤ºä¾‹

```typescript
// app/(dashboard)/reports/page.tsx
import { ReportProvider } from '@/contexts/report-context'
import { ReportFilters } from '@/components/reports/report-filters'
import { ReportStats } from '@/components/reports/report-stats'
// ... å…¶ä»–ç»„ä»¶å¯¼å…¥

export default function ReportsPage() {
  return (
    <ReportProvider>
      <div className="space-y-6">
        <div>
          <h1 className="text-2xl font-bold text-[#333333]">æŠ¥è¡¨ä¸­å¿ƒ</h1>
          <p className="text-sm text-[#6B7280] mt-1">æŸ¥çœ‹è¥ä¸šæ•°æ®å’Œç»è¥åˆ†æ</p>
        </div>

        <ReportFilters />
        <ReportStats />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <div className="lg:col-span-2">
            <RevenueChart />
          </div>
          <div>
            <CategoryChart />
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          <TopDishes />
          <HourlyAnalysis />
        </div>
      </div>
    </ReportProvider>
  )
}
```

---

## 5. æ•°æ®èšåˆé€»è¾‘

### 5.1 Prisma æŸ¥è¯¢ä¼˜åŒ–

#### ä½¿ç”¨ç´¢å¼•åŠ é€ŸæŸ¥è¯¢

ç¡®ä¿ `Order` è¡¨æœ‰ä»¥ä¸‹ç´¢å¼•ï¼š

```prisma
model Order {
  // ... å…¶ä»–å­—æ®µ
  createdAt  DateTime @default(now())

  @@index([createdAt])
  @@index([createdAt, isPaid])
  @@index([status, createdAt])
}
```

#### å¤æ‚èšåˆæŸ¥è¯¢ç¤ºä¾‹

```typescript
// æŒ‰æ—¥æœŸå’Œåˆ†ç±»èšåˆé”€å”®æ•°æ®
const categorySalesByDate = await prisma.$queryRaw`
  SELECT
    DATE(o.createdAt) as date,
    c.id as categoryId,
    c.name as categoryName,
    SUM(oi.subtotal) as totalRevenue,
    SUM(oi.quantity) as totalQuantity
  FROM OrderItem oi
  JOIN \`Order\` o ON oi.orderId = o.id
  JOIN Dish d ON oi.dishId = d.id
  JOIN Category c ON d.categoryId = c.id
  WHERE
    o.createdAt >= ${startDate}
    AND o.createdAt <= ${endDate}
    AND o.isPaid = 1
  GROUP BY date, c.id, c.name
  ORDER BY date ASC, totalRevenue DESC
`
```

### 5.2 æ•°æ®è®¡ç®—è§„åˆ™

#### å¢é•¿ç‡è®¡ç®—

```typescript
function calculateGrowth(current: number, previous: number): number {
  if (previous === 0) return current > 0 ? 100 : 0
  return ((current - previous) / previous) * 100
}
```

#### ç™¾åˆ†æ¯”è®¡ç®—

```typescript
function calculatePercentage(part: number, total: number): number {
  if (total === 0) return 0
  return (part / total) * 100
}
```

#### ç§»åŠ¨å¹³å‡è®¡ç®—ï¼ˆç”¨äºè¶‹åŠ¿åˆ†æï¼‰

```typescript
function calculateMovingAverage(data: number[], window: number): number[] {
  const result: number[] = []

  for (let i = 0; i < data.length; i++) {
    const start = Math.max(0, i - window + 1)
    const slice = data.slice(start, i + 1)
    const avg = slice.reduce((sum, val) => sum + val, 0) / slice.length
    result.push(avg)
  }

  return result
}
```

### 5.3 ç¼“å­˜ç­–ç•¥

#### SWR ç¼“å­˜é…ç½®

```typescript
// lib/swr-config.ts
export const swrConfig = {
  revalidateOnFocus: false,
  revalidateOnReconnect: true,
  refreshInterval: 60000, // æ¯åˆ†é’Ÿè‡ªåŠ¨åˆ·æ–°
  dedupingInterval: 5000, // 5ç§’å†…å»é‡
}

// ä½¿ç”¨
const { data } = useSWR('/api/reports/overview', fetcher, swrConfig)
```

#### æœåŠ¡ç«¯ç¼“å­˜ï¼ˆå¯é€‰ï¼‰

```typescript
// ä½¿ç”¨ Next.js Route Handlers ç¼“å­˜
export const revalidate = 300 // 5åˆ†é’Ÿç¼“å­˜

// æˆ–ä½¿ç”¨ Redis ç¼“å­˜
import { redis } from '@/lib/redis'

async function getCachedReportData(key: string, ttl: number, generator: () => Promise<any>) {
  const cached = await redis.get(key)
  if (cached) return JSON.parse(cached)

  const data = await generator()
  await redis.setex(key, ttl, JSON.stringify(data))
  return data
}
```

---

## 6. ç­›é€‰å™¨å®ç°

### 6.1 æ—¥æœŸèŒƒå›´å¤„ç†

```typescript
// components/reports/report-filters.tsx
'use client'

import { useState } from 'react'
import { useReport } from '@/contexts/report-context'
import { getDateRange, getComparisonRange } from '@/lib/date-utils'

export function ReportFilters() {
  const { setFilters } = useReport()
  const [dateRange, setDateRange] = useState('today')

  const handleDateRangeChange = (value: string) => {
    setDateRange(value)

    const { start, end } = getDateRange(value)
    const { start: compareStart, end: compareEnd } = getComparisonRange(value)

    setFilters({
      startDate: start.toISOString(),
      endDate: end.toISOString(),
      compareStartDate: compareStart.toISOString(),
      compareEndDate: compareEnd.toISOString(),
      reportType: 'all',
    })
  }

  return (
    <Select value={dateRange} onValueChange={handleDateRangeChange}>
      {/* ... */}
    </Select>
  )
}
```

### 6.2 åŠ¨æ€æŸ¥è¯¢æ„å»º

```typescript
// lib/query-builder.ts
export function buildReportQuery(filters: ReportFilters) {
  const where: any = {
    createdAt: {
      gte: new Date(filters.startDate),
      lte: new Date(filters.endDate),
    },
    isPaid: true,
  }

  // æ ¹æ®æŠ¥è¡¨ç±»å‹æ·»åŠ é¢å¤–æ¡ä»¶
  if (filters.reportType === 'revenue') {
    // åªæŸ¥è¯¢è¥ä¸šé¢ç›¸å…³
  } else if (filters.reportType === 'dishes') {
    // åªæŸ¥è¯¢èœå“ç›¸å…³
  }

  return where
}
```

### 6.3 å‚æ•°ä¼ é€’æ–¹æ¡ˆ

ä½¿ç”¨ URL æŸ¥è¯¢å‚æ•°ä¿æŒçŠ¶æ€ï¼š

```typescript
// ä½¿ç”¨ Next.js useSearchParams
'use client'

import { useSearchParams, useRouter } from 'next/navigation'

export function ReportFilters() {
  const router = useRouter()
  const searchParams = useSearchParams()

  const updateFilters = (newFilters: Partial<ReportFilters>) => {
    const params = new URLSearchParams(searchParams)

    Object.entries(newFilters).forEach(([key, value]) => {
      if (value) params.set(key, value)
      else params.delete(key)
    })

    router.push(`/reports?${params.toString()}`)
  }

  // ...
}
```

---

## 7. å›¾è¡¨é…ç½®

### 7.1 Recharts é…ç½®è¯¦è§£

#### æŸ±çŠ¶å›¾ï¼ˆè¥ä¸šé¢è¶‹åŠ¿ï¼‰

```typescript
<BarChart data={data}>
  <CartesianGrid
    strokeDasharray="3 3"
    stroke="#E0E6ED"
    vertical={false}
  />

  <XAxis
    dataKey="date"
    stroke="#6B7280"
    fontSize={12}
    tickLine={false}
    axisLine={false}
    tickFormatter={(value) => format(new Date(value), 'MM/dd')}
  />

  <YAxis
    yAxisId="left"
    stroke="#6B7280"
    fontSize={12}
    tickLine={false}
    axisLine={false}
    tickFormatter={(value) => `Â¥${value / 1000}k`}
  />

  <Tooltip
    contentStyle={{
      backgroundColor: '#FFFFFF',
      border: '1px solid #E0E6ED',
      borderRadius: '8px',
      boxShadow: '0 2px 6px rgba(0,0,0,0.05)',
    }}
    formatter={(value: number, name: string) => {
      if (name === 'revenue') return [`Â¥${value.toLocaleString()}`, 'è¥ä¸šé¢']
      if (name === 'orders') return [value, 'è®¢å•æ•°']
      return [value, name]
    }}
  />

  <Legend
    wrapperStyle={{ paddingTop: '20px' }}
    iconType="circle"
  />

  <Bar
    yAxisId="left"
    dataKey="revenue"
    fill="#1E90FF"
    radius={[4, 4, 0, 0]}
    animationDuration={800}
  />
</BarChart>
```

#### é¥¼å›¾ï¼ˆåˆ†ç±»å æ¯”ï¼‰

```typescript
<PieChart>
  <Pie
    data={data}
    cx="50%"
    cy="50%"
    labelLine={false}
    label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
    outerRadius={100}
    innerRadius={60} // ç¯å½¢å›¾
    fill="#8884d8"
    dataKey="value"
    animationBegin={0}
    animationDuration={800}
  >
    {data.map((entry, index) => (
      <Cell key={`cell-${index}`} fill={entry.color} />
    ))}
  </Pie>

  <Tooltip
    formatter={(value: number) => [`Â¥${value.toLocaleString()}`, 'é”€å”®é¢']}
  />
</PieChart>
```

### 7.2 é¢œè‰²ä¸»é¢˜è§„èŒƒ

```typescript
// lib/chart-colors.ts
export const CHART_COLORS = {
  primary: '#1E90FF',      // è“è‰² - ä¸»è‰²
  success: '#28C76F',      // ç»¿è‰² - æˆåŠŸ/å¢é•¿
  warning: '#FFB400',      // é»„è‰² - è­¦å‘Š
  danger: '#EA5455',       // çº¢è‰² - é”™è¯¯/ä¸‹é™
  secondary: '#5A6B7B',    // ç°è‰² - æ¬¡è¦ä¿¡æ¯

  // åˆ†ç±»é¢œè‰²ï¼ˆç”¨äºé¥¼å›¾ç­‰ï¼‰
  categories: [
    '#1E90FF',
    '#28C76F',
    '#FFB400',
    '#5A6B7B',
    '#EA5455',
    '#00CFE8',
    '#7367F0',
  ],
}

// æ ¹æ®å¢é•¿ç‡è¿”å›é¢œè‰²
export function getGrowthColor(growth: number): string {
  if (growth > 0) return CHART_COLORS.success
  if (growth < 0) return CHART_COLORS.danger
  return CHART_COLORS.secondary
}
```

### 7.3 å“åº”å¼è®¾è®¡

```typescript
// ä½¿ç”¨ ResponsiveContainer å®ç°å“åº”å¼
<ResponsiveContainer width="100%" height={320}>
  <BarChart data={data}>
    {/* ... */}
  </BarChart>
</ResponsiveContainer>

// ç§»åŠ¨ç«¯ä¼˜åŒ–
const isMobile = useMediaQuery('(max-width: 768px)')

<ResponsiveContainer width="100%" height={isMobile ? 250 : 320}>
  {/* ... */}
</ResponsiveContainer>
```

---

## 8. å¯¼å‡ºåŠŸèƒ½

### 8.1 Excel å¯¼å‡º

å®‰è£…ä¾èµ–ï¼š

```bash
pnpm add xlsx
pnpm add -D @types/node
```

å®ç°å¯¼å‡ºå·¥å…·ï¼š

```typescript
// lib/export-excel.ts
import * as XLSX from 'xlsx'
import type { ReportOverview } from '@/types/reports'

export function exportToExcel(data: ReportOverview, filename: string) {
  // åˆ›å»ºå·¥ä½œç°¿
  const wb = XLSX.utils.book_new()

  // 1. æ ¸å¿ƒç»Ÿè®¡è¡¨
  const statsData = [
    ['æŒ‡æ ‡', 'æ•°å€¼', 'å¢é•¿ç‡'],
    ['æ€»è¥ä¸šé¢', `Â¥${data.stats.totalRevenue}`, `${data.stats.comparison?.revenueGrowth || 0}%`],
    ['è®¢å•æ€»æ•°', data.stats.totalOrders, `${data.stats.comparison?.ordersGrowth || 0}%`],
    ['å®¢å•ä»·', `Â¥${data.stats.avgOrderValue}`, `${data.stats.comparison?.avgOrderGrowth || 0}%`],
    ['åˆ©æ¶¦ç‡', `${data.stats.profitRate}%`, '-'],
  ]
  const statsSheet = XLSX.utils.aoa_to_sheet(statsData)
  XLSX.utils.book_append_sheet(wb, statsSheet, 'æ ¸å¿ƒç»Ÿè®¡')

  // 2. è¥ä¸šé¢è¶‹åŠ¿è¡¨
  const revenueData = [
    ['æ—¥æœŸ', 'è¥ä¸šé¢', 'è®¢å•æ•°', 'å®¢å•ä»·'],
    ...data.revenueChart.map(item => [
      item.date,
      item.revenue,
      item.orders,
      item.avgOrder,
    ]),
  ]
  const revenueSheet = XLSX.utils.aoa_to_sheet(revenueData)
  XLSX.utils.book_append_sheet(wb, revenueSheet, 'è¥ä¸šé¢è¶‹åŠ¿')

  // 3. çƒ­é”€èœå“è¡¨
  const dishesData = [
    ['æ’å', 'èœå“åç§°', 'é”€é‡', 'è¥ä¸šé¢', 'å¢é•¿ç‡'],
    ...data.topDishes.map((item, index) => [
      index + 1,
      item.dishName,
      item.sales,
      item.revenue,
      `${item.growth}%`,
    ]),
  ]
  const dishesSheet = XLSX.utils.aoa_to_sheet(dishesData)
  XLSX.utils.book_append_sheet(wb, dishesSheet, 'çƒ­é”€èœå“')

  // å¯¼å‡ºæ–‡ä»¶
  XLSX.writeFile(wb, `${filename}.xlsx`)
}
```

### 8.2 PDF å¯¼å‡º

å®‰è£…ä¾èµ–ï¼š

```bash
pnpm add jspdf jspdf-autotable
pnpm add -D @types/jspdf
```

å®ç°å¯¼å‡ºå·¥å…·ï¼š

```typescript
// lib/export-pdf.ts
import jsPDF from 'jspdf'
import autoTable from 'jspdf-autotable'
import type { ReportOverview } from '@/types/reports'

export function exportToPDF(data: ReportOverview, filename: string) {
  const doc = new jsPDF()

  // æ·»åŠ ä¸­æ–‡å­—ä½“æ”¯æŒï¼ˆéœ€è¦é¢å¤–é…ç½®ï¼‰
  // doc.addFont('path/to/font.ttf', 'CustomFont', 'normal')
  // doc.setFont('CustomFont')

  // æ ‡é¢˜
  doc.setFontSize(18)
  doc.text('è¥ä¸šæŠ¥è¡¨', 14, 20)

  // æ—¥æœŸèŒƒå›´
  doc.setFontSize(10)
  doc.text(`ç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-CN')}`, 14, 30)

  // æ ¸å¿ƒç»Ÿè®¡è¡¨
  autoTable(doc, {
    startY: 40,
    head: [['æŒ‡æ ‡', 'æ•°å€¼', 'å¢é•¿ç‡']],
    body: [
      ['æ€»è¥ä¸šé¢', `Â¥${data.stats.totalRevenue}`, `${data.stats.comparison?.revenueGrowth || 0}%`],
      ['è®¢å•æ€»æ•°', data.stats.totalOrders.toString(), `${data.stats.comparison?.ordersGrowth || 0}%`],
      ['å®¢å•ä»·', `Â¥${data.stats.avgOrderValue}`, `${data.stats.comparison?.avgOrderGrowth || 0}%`],
    ],
  })

  // çƒ­é”€èœå“è¡¨
  autoTable(doc, {
    startY: (doc as any).lastAutoTable.finalY + 10,
    head: [['æ’å', 'èœå“åç§°', 'é”€é‡', 'è¥ä¸šé¢']],
    body: data.topDishes.map((item, index) => [
      (index + 1).toString(),
      item.dishName,
      item.sales.toString(),
      `Â¥${item.revenue}`,
    ]),
  })

  // ä¿å­˜ PDF
  doc.save(`${filename}.pdf`)
}
```

### 8.3 å¯¼å‡ºæŒ‰é’®å®ç°

```typescript
// components/reports/export-buttons.tsx
'use client'

import { Download } from 'lucide-react'
import { Button } from '@/components/ui/button'
import { useReport } from '@/contexts/report-context'
import { exportToExcel } from '@/lib/export-excel'
import { exportToPDF } from '@/lib/export-pdf'
import { toast } from 'sonner'

export function ExportButtons() {
  const { data } = useReport()

  const handleExportExcel = () => {
    if (!data) {
      toast.error('æš‚æ— æ•°æ®å¯å¯¼å‡º')
      return
    }

    try {
      const filename = `è¥ä¸šæŠ¥è¡¨_${new Date().toISOString().split('T')[0]}`
      exportToExcel(data, filename)
      toast.success('Excel å¯¼å‡ºæˆåŠŸ')
    } catch (error) {
      toast.error('å¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•')
    }
  }

  const handleExportPDF = () => {
    if (!data) {
      toast.error('æš‚æ— æ•°æ®å¯å¯¼å‡º')
      return
    }

    try {
      const filename = `è¥ä¸šæŠ¥è¡¨_${new Date().toISOString().split('T')[0]}`
      exportToPDF(data, filename)
      toast.success('PDF å¯¼å‡ºæˆåŠŸ')
    } catch (error) {
      toast.error('å¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•')
    }
  }

  return (
    <div className="flex gap-2">
      <Button
        variant="outline"
        onClick={handleExportExcel}
        disabled={!data}
      >
        <Download className="h-4 w-4 mr-2" />
        å¯¼å‡º Excel
      </Button>

      <Button
        variant="outline"
        onClick={handleExportPDF}
        disabled={!data}
      >
        <Download className="h-4 w-4 mr-2" />
        å¯¼å‡º PDF
      </Button>
    </div>
  )
}
```

---

## 9. æ€§èƒ½ä¼˜åŒ–

### 9.1 æ•°æ®åº“ç´¢å¼•å»ºè®®

```prisma
// prisma/schema.prisma

model Order {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  isPaid     Boolean  @default(false)
  status     String

  // æ·»åŠ å¤åˆç´¢å¼•æå‡æŸ¥è¯¢æ€§èƒ½
  @@index([createdAt, isPaid])
  @@index([status, createdAt])
  @@index([isPaid, status, createdAt])
}

model OrderItem {
  id        String   @id @default(cuid())
  orderId   String
  dishId    String
  createdAt DateTime @default(now())

  @@index([dishId, createdAt])
  @@index([orderId, dishId])
}
```

### 9.2 åˆ†é¡µä¸æ‡’åŠ è½½

```typescript
// ä½¿ç”¨æ¸¸æ ‡åˆ†é¡µä¼˜åŒ–å¤§æ•°æ®é‡æŸ¥è¯¢
async function getPaginatedOrders(cursor?: string, limit: number = 50) {
  return await prisma.order.findMany({
    take: limit,
    skip: cursor ? 1 : 0,
    cursor: cursor ? { id: cursor } : undefined,
    orderBy: { createdAt: 'desc' },
  })
}

// å‰ç«¯ä½¿ç”¨ SWR Infinite å®ç°æ— é™æ»šåŠ¨
import useSWRInfinite from 'swr/infinite'

const getKey = (pageIndex: number, previousPageData: any) => {
  if (previousPageData && !previousPageData.hasMore) return null
  return `/api/reports/orders?page=${pageIndex}`
}

const { data, size, setSize } = useSWRInfinite(getKey, fetcher)
```

### 9.3 ç¼“å­˜æœºåˆ¶

#### ä½¿ç”¨ React Queryï¼ˆæ›¿ä»£æ–¹æ¡ˆï¼‰

```typescript
// å¦‚æœä½¿ç”¨ React Query ä»£æ›¿ SWR
import { useQuery } from '@tanstack/react-query'

export function useReportData(filters: ReportFilters) {
  return useQuery({
    queryKey: ['reports', filters],
    queryFn: () => fetchReportData(filters),
    staleTime: 5 * 60 * 1000, // 5åˆ†é’Ÿå†…æ•°æ®è§†ä¸ºæ–°é²œ
    cacheTime: 10 * 60 * 1000, // ç¼“å­˜10åˆ†é’Ÿ
  })
}
```

#### æœåŠ¡ç«¯ç¼“å­˜

```typescript
// ä½¿ç”¨ Next.js å†…ç½®ç¼“å­˜
export const revalidate = 300 // 5åˆ†é’Ÿ

// æˆ–ä½¿ç”¨ unstable_cache
import { unstable_cache } from 'next/cache'

const getCachedReportData = unstable_cache(
  async (startDate: string, endDate: string) => {
    return await getReportStats(new Date(startDate), new Date(endDate))
  },
  ['report-stats'],
  { revalidate: 300, tags: ['reports'] }
)
```

### 9.4 æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§

```typescript
// 1. ä½¿ç”¨ select åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
const orders = await prisma.order.findMany({
  select: {
    id: true,
    totalPrice: true,
    createdAt: true,
  },
})

// 2. ä½¿ç”¨ parallel queries å¹¶è¡ŒæŸ¥è¯¢
const [stats, topDishes, hourlyData] = await Promise.all([
  getReportStats(startDate, endDate),
  getTopDishes(startDate, endDate, 5),
  getHourlyAnalysis(startDate, endDate),
])

// 3. ä½¿ç”¨ aggregation ä»£æ›¿å¤šæ¬¡æŸ¥è¯¢
const stats = await prisma.order.aggregate({
  where: { isPaid: true },
  _sum: { totalPrice: true },
  _count: true,
  _avg: { totalPrice: true },
})
```

---

## 10. ä½¿ç”¨ç¤ºä¾‹

### 10.1 API è°ƒç”¨ç¤ºä¾‹

#### è·å–ç»¼åˆæŠ¥è¡¨

```typescript
// è·å–ä»Šæ—¥æŠ¥è¡¨
const response = await fetch('/api/reports/overview?' + new URLSearchParams({
  startDate: new Date(new Date().setHours(0,0,0,0)).toISOString(),
  endDate: new Date().toISOString(),
}))

const { success, data } = await response.json()

if (success) {
  console.log('è¥ä¸šé¢:', data.stats.totalRevenue)
  console.log('è®¢å•æ•°:', data.stats.totalOrders)
}
```

#### è·å–æœ¬å‘¨æŠ¥è¡¨ï¼ˆå«å¯¹æ¯”ï¼‰

```typescript
import { startOfWeek, endOfWeek, subWeeks } from 'date-fns'

const thisWeekStart = startOfWeek(new Date(), { weekStartsOn: 1 })
const thisWeekEnd = endOfWeek(new Date(), { weekStartsOn: 1 })
const lastWeekStart = startOfWeek(subWeeks(new Date(), 1), { weekStartsOn: 1 })
const lastWeekEnd = endOfWeek(subWeeks(new Date(), 1), { weekStartsOn: 1 })

const response = await fetch('/api/reports/overview?' + new URLSearchParams({
  startDate: thisWeekStart.toISOString(),
  endDate: thisWeekEnd.toISOString(),
  compareStartDate: lastWeekStart.toISOString(),
  compareEndDate: lastWeekEnd.toISOString(),
}))
```

### 10.2 ç»„ä»¶é›†æˆç¤ºä¾‹

#### åœ¨é¡µé¢ä¸­ä½¿ç”¨æŠ¥è¡¨ç»„ä»¶

```typescript
// app/(dashboard)/reports/page.tsx
import { Suspense } from 'react'
import { ReportProvider } from '@/contexts/report-context'
import { ReportFilters } from '@/components/reports/report-filters'
import { ReportStats } from '@/components/reports/report-stats'
import { Skeleton } from '@/components/ui/skeleton'

export default function ReportsPage() {
  return (
    <ReportProvider>
      <div className="space-y-6">
        <PageHeader />

        <Suspense fallback={<Skeleton className="h-20" />}>
          <ReportFilters />
        </Suspense>

        <Suspense fallback={<Skeleton className="h-40" />}>
          <ReportStats />
        </Suspense>

        <ChartsSection />
        <TablesSection />
      </div>
    </ReportProvider>
  )
}
```

#### è‡ªå®šä¹‰æŠ¥è¡¨ç»„ä»¶

```typescript
// components/custom/monthly-revenue.tsx
'use client'

import { useReport } from '@/contexts/report-context'
import { Card } from '@/components/ui/card'
import { formatCurrency } from '@/lib/utils'

export function MonthlyRevenue() {
  const { data, isLoading } = useReport()

  if (isLoading) return <Card className="p-6">åŠ è½½ä¸­...</Card>
  if (!data) return null

  const monthlyRevenue = data.revenueChart.reduce(
    (sum, item) => sum + item.revenue,
    0
  )

  return (
    <Card className="p-6">
      <h3 className="text-lg font-semibold">æœ¬æœˆè¥ä¸šé¢</h3>
      <p className="text-3xl font-bold text-[#1E90FF] mt-2">
        {formatCurrency(monthlyRevenue)}
      </p>
    </Card>
  )
}
```

### 10.3 å¸¸è§é—®é¢˜è§£ç­”

#### Q1: å¦‚ä½•æ›´æ”¹æŠ¥è¡¨çš„é»˜è®¤æ—¥æœŸèŒƒå›´ï¼Ÿ

```typescript
// åœ¨ ReportProvider ä¸­ä¿®æ”¹åˆå§‹çŠ¶æ€
const [filters, setFilters] = useState<ReportFilters>({
  startDate: startOfMonth(new Date()).toISOString(), // æ”¹ä¸ºæœ¬æœˆå¼€å§‹
  endDate: new Date().toISOString(),
  reportType: 'all',
})
```

#### Q2: å¦‚ä½•æ·»åŠ æ–°çš„ç»Ÿè®¡æŒ‡æ ‡ï¼Ÿ

1. åœ¨ `types/reports.ts` ä¸­æ·»åŠ æ–°å­—æ®µ
2. åœ¨ API ä¸­å®ç°è®¡ç®—é€»è¾‘
3. åœ¨ `ReportStats` ç»„ä»¶ä¸­æ·»åŠ æ–°å¡ç‰‡

```typescript
// types/reports.ts
export interface ReportStats {
  // ... ç°æœ‰å­—æ®µ
  customerCount: number  // æ–°å¢ï¼šå®¢æˆ·æ•°
}

// API ä¸­è®¡ç®—
const customerCount = await prisma.order.groupBy({
  by: ['userId'],
  where: { /* ... */ },
  _count: true,
})

// ç»„ä»¶ä¸­æ˜¾ç¤º
<StatCard
  title="å®¢æˆ·æ•°"
  value={stats.customerCount}
  icon={Users}
  color="#1E90FF"
/>
```

#### Q3: å¦‚ä½•ä¼˜åŒ–å¤§æ•°æ®é‡çš„æŠ¥è¡¨æ€§èƒ½ï¼Ÿ

1. **ä½¿ç”¨æ•°æ®åº“ç´¢å¼•**ï¼ˆè§ 9.1 èŠ‚ï¼‰
2. **å®ç°åˆ†é¡µåŠ è½½**ï¼ˆè§ 9.2 èŠ‚ï¼‰
3. **å¯ç”¨ç¼“å­˜**ï¼ˆè§ 9.3 èŠ‚ï¼‰
4. **ä½¿ç”¨ SQL èšåˆä»£æ›¿åº”ç”¨å±‚è®¡ç®—**

```typescript
// âŒ ä¸æ¨èï¼šåº”ç”¨å±‚è®¡ç®—
const orders = await prisma.order.findMany({ where: { isPaid: true } })
const total = orders.reduce((sum, o) => sum + o.totalPrice, 0)

// âœ… æ¨èï¼šæ•°æ®åº“èšåˆ
const { _sum } = await prisma.order.aggregate({
  where: { isPaid: true },
  _sum: { totalPrice: true },
})
```

#### Q4: å¦‚ä½•å®ç°å®æ—¶æ•°æ®æ›´æ–°ï¼Ÿ

ä½¿ç”¨ SWR çš„è‡ªåŠ¨é‡æ–°éªŒè¯åŠŸèƒ½ï¼š

```typescript
const { data } = useSWR('/api/reports/overview', fetcher, {
  refreshInterval: 30000, // æ¯30ç§’è‡ªåŠ¨åˆ·æ–°
  revalidateOnFocus: true, // çª—å£èšç„¦æ—¶åˆ·æ–°
})
```

æˆ–ä½¿ç”¨ WebSocket æ¨é€ï¼ˆæ›´é«˜çº§ï¼‰ï¼š

```typescript
// å»ºç«‹ WebSocket è¿æ¥
const ws = new WebSocket('ws://localhost:3000/api/ws')

ws.onmessage = (event) => {
  const newData = JSON.parse(event.data)
  mutate('/api/reports/overview', newData, false)
}
```

---

## 11. æ€»ç»“

### 11.1 å·²å®ç°åŠŸèƒ½

âœ… å®Œæ•´çš„å‰ç«¯æŠ¥è¡¨ç»„ä»¶ä½“ç³»
âœ… æ•°æ®å¯è§†åŒ–ï¼ˆæŸ±çŠ¶å›¾ã€é¥¼å›¾ã€è¡¨æ ¼ï¼‰
âœ… å“åº”å¼è®¾è®¡å’Œç§»åŠ¨ç«¯é€‚é…
âœ… ç»Ÿä¸€çš„ UI é£æ ¼å’Œäº¤äº’ä½“éªŒ

### 11.2 å¾…å®ç°åŠŸèƒ½

â³ åç«¯ API è·¯ç”±å®ç°
â³ æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
â³ Excel/PDF å¯¼å‡ºåŠŸèƒ½
â³ å®æ—¶æ•°æ®æ¨é€
â³ é«˜çº§ç­›é€‰å’Œè‡ªå®šä¹‰æŠ¥è¡¨

### 11.3 æ‰©å±•å»ºè®®

1. **ç§»åŠ¨ç«¯ä¸“å±æŠ¥è¡¨** - è®¾è®¡æ›´é€‚åˆæ‰‹æœºæŸ¥çœ‹çš„æŠ¥è¡¨ç•Œé¢
2. **è‡ªå®šä¹‰æŠ¥è¡¨æ¨¡æ¿** - å…è®¸ç”¨æˆ·ä¿å­˜å¸¸ç”¨çš„æŠ¥è¡¨é…ç½®
3. **é‚®ä»¶è®¢é˜…** - å®šæ—¶å‘é€æŠ¥è¡¨åˆ°é‚®ç®±
4. **å¯¹æ¯”åˆ†æ** - å¤šæ—¶æ®µã€å¤šç»´åº¦çš„å¯¹æ¯”åˆ†æ
5. **é¢„æµ‹åˆ†æ** - åŸºäºå†å²æ•°æ®çš„é”€å”®é¢„æµ‹
6. **å¤šé—¨åº—æ”¯æŒ** - æ”¯æŒå¤šé—¨åº—çš„æ•°æ®æ±‡æ€»å’Œå¯¹æ¯”

---

## é™„å½•

### A. ç›¸å…³æ–‡ä»¶æ¸…å•

| æ–‡ä»¶è·¯å¾„ | è¯´æ˜ |
|---------|------|
| `app/(dashboard)/reports/page.tsx` | æŠ¥è¡¨é¡µé¢ä¸»æ–‡ä»¶ |
| `components/reports/report-filters.tsx` | ç­›é€‰å™¨ç»„ä»¶ |
| `components/reports/report-stats.tsx` | ç»Ÿè®¡å¡ç‰‡ç»„ä»¶ |
| `components/reports/revenue-chart.tsx` | è¥ä¸šé¢å›¾è¡¨ç»„ä»¶ |
| `components/reports/category-chart.tsx` | åˆ†ç±»å›¾è¡¨ç»„ä»¶ |
| `components/reports/top-dishes.tsx` | çƒ­é”€èœå“ç»„ä»¶ |
| `components/reports/hourly-analysis.tsx` | æ—¶æ®µåˆ†æç»„ä»¶ |
| `types/reports.ts` | æŠ¥è¡¨ç±»å‹å®šä¹‰ |
| `lib/report-utils.ts` | æŠ¥è¡¨å·¥å…·å‡½æ•° |
| `lib/date-utils.ts` | æ—¥æœŸå¤„ç†å·¥å…· |
| `contexts/report-context.tsx` | æŠ¥è¡¨ä¸Šä¸‹æ–‡ |

### B. æŠ€æœ¯æ ˆç‰ˆæœ¬

- Next.js: 15.2.4
- React: 19
- TypeScript: 5.x
- Prisma: 6.16.3
- Recharts: latest
- date-fns: 4.1.0
- SWR: 2.3.6
- xlsx: (å¾…å®‰è£…)
- jspdf: (å¾…å®‰è£…)

### C. å‚è€ƒèµ„æº

- [Recharts å®˜æ–¹æ–‡æ¡£](https://recharts.org/)
- [Prisma Aggregation æ–‡æ¡£](https://www.prisma.io/docs/concepts/components/prisma-client/aggregation-grouping-summarizing)
- [SWR å®˜æ–¹æ–‡æ¡£](https://swr.vercel.app/)
- [date-fns æ–‡æ¡£](https://date-fns.org/)

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**æœ€åæ›´æ–°**: 2025-10-07
**ç»´æŠ¤è€…**: å¼€å‘å›¢é˜Ÿ
